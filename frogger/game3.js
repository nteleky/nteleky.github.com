/* Comp20 - Frogger Assignment Part 1 * Nicholas Teleky * * Contains all code for rendering graphics. *//* * Globals */ //Most used variablesvar gameCanvas, gameCanvasContext, spriteSheet, deadFrogImage;//Interval that controls redrawing the gamevar redrawInterval, drawVehicleInterval, drawLogInterval;//Holds all of the sprite objects that need to be drawnvar activeSpriteObjects = [];//Initial statesvar frogStartPosX = 190, frogStartPosY = 490;//Makeshift enum for frog directioningvar Direction_North = 0, Direction_East = 1, Direction_South = 2, Direction_West = 3;//Gamestate variablesvar gs_frogPosX, gs_frogPosY, gs_frogDirection, gs_currentScore, gs_highScore, gs_livesLeft, gs_levelNumber, gs_frogDirection;//The Flyvar flySprite = null;//Locations that can be landed on to winvar usedEndSlots = [0,0,0,0,0];var endSlots = [    {CropX: 39, CropY: 38, PosX: 7, PosY: 70},    {CropX: 39, CropY: 38, PosX: 93, PosY: 70},    {CropX: 39, CropY: 38, PosX: 178, PosY: 70},    {CropX: 39, CropY: 38, PosX: 262, PosY: 70},    {CropX: 39, CropY: 38, PosX: 347, PosY: 70} ];/* * Sprite locations */ //Game overvar gameOverText = {CropX: 283, CropY: 229, PosX: 59, PosY: 438};var flyWest = {CropX: 16, CropY: 16, PosX: 140, PosY: 236};var flyNorth = {CropX: 16, CropY: 16, PosX: 158, PosY: 236};var flySouth = {CropX: 16, CropY: 16, PosX: 140, PosY: 219};var flyEast = {CropX: 16, CropY: 16, PosX: 158, PosY: 219}; var turtleSprites = [{CropX: 33, CropY: 24, PosX: 14, PosY: 405}, //Normal frame 1{CropX: 33, CropY: 24, PosX: 53, PosY: 406}, //Normal frame 2{CropX: 33, CropY: 24, PosX: 92, PosY: 406}, //Submerge frame 1{CropX: 33, CropY: 24, PosX: 132, PosY: 406}, //Submerge frame 2{CropX: 33, CropY: 24, PosX: 175, PosY: 406}, //Submerge fame 3];//Leftwards vehiclesvar leftVehicleSprites = [{CropX: 48, CropY: 20, PosX: 105, PosY: 301},{CropX: 32, CropY: 22, PosX: 8, PosY: 266},{CropX: 27, CropY: 27, PosX: 80, PosY: 263}];//Rightwards vehiclesvar rightVehicleSprites = [{CropX: 27, CropY: 24, PosX: 47, PosY: 265},{CropX: 37, CropY: 27, PosX: 72, PosY: 298}];//Logsvar logSprites = [ {CropX: 180, CropY: 23, PosX: 6, PosY: 165}, {CropX: 120, CropY: 23, PosX: 6, PosY: 197}, {CropX: 88, CropY: 23, PosX: 6, PosY: 229} ];/* * Constructors for autonomous objects  */function Sprite(spriteVars, direction, startPosX, startPosY, speed) {    this.widthX = spriteVars.CropX;    this.widthY = spriteVars.CropY;    this.cropX = spriteVars.PosX;    this.cropY = spriteVars.PosY;    this.direction = direction;    this.PosX = startPosX;    this.PosY = startPosY;    this.speed = speed;    //Initialised by the appropriate generator    this.isDeadly = false;    this.isPlatform = false;    this.expires = false;}function spritesOverlap(spriteA, spriteB){    if (spriteA == null || spriteB == null) return false;    if ((spriteA.PosX + spriteA.widthX) < spriteB.PosX) return false;    if (spriteA.PosX > spriteB.PosX + spriteB.widthX) return false;     if ((spriteA.PosY + spriteA.widthY) < spriteB.PosY) return false;    if (spriteA.PosY > spriteB.PosY + spriteB.widthY) return false;    return true;}function spriteIsOnCanvas(sprite){    return ((sprite.PosX <= gameCanvas.width + 10) && (sprite.PosX + sprite.widthX) > - 10);};/* * Calls the update function of each sprite * Draws the base game graphics * Draws all sprite objects * Checks if frogger is on a platform / under a truck * Draws frogger */function updateGame(){    draw_background();    draw_score_info(gs_currentScore, gs_highScore);    draw_life_count(gs_livesLeft);    draw_level_count(gs_levelNumber);    update_sprites();    win_check();    collision_check();    drowning_check();    draw_frog(gs_frogPosX, gs_frogPosY, gs_frogDirection, false);    if (Math.floor(Math.random() * 10000) == 0 && flySprite != null){        generate_Fly();    }    if (flySprite != null){        flySprite.update();        var froggerSprite = new Sprite(((gs_frogDirection == Direction_North || gs_frogDirection == Direction_South) ? {CropX: 22, CropY: 16} : {CropX: 16, CropY: 22}), null, gs_frogPosX, gs_frogPosY, null);        if (spritesOverlap(froggerSprite, flySprite)){            gs_currentScore += 1000;            flySprite = null;        }    }}function win_check(){    var froggerSprite = new Sprite(((gs_frogDirection == Direction_North || gs_frogDirection == Direction_South) ? {CropX: 24, CropY: 18} : {CropX: 18, CropY: 20}), null, gs_frogPosX, gs_frogPosY, null);    for (var SI = 0 ; SI < endSlots.length; SI++){        if (spritesOverlap(new Sprite(endSlots[SI], null, endSlots[SI].PosX, endSlots[SI].PosY, null), froggerSprite)){            if (usedEndSlots[SI] == 1){                frogger_dies(); //Cannot reuse landing spots!            } else {                froggerLands(SI);            }            return true;        }    }    return false;}function froggerLands(SI){    usedEndSlots[SI] = 1;    var placeholderSprite = new Sprite({CropX: 24, CropY: 18, PosX: 80, PosY: 368}, Direction_South, endSlots[SI].PosX + 7, endSlots[SI].PosY + 10, 0);    placeholderSprite.update = function() {};    activeSpriteObjects.push(placeholderSprite);    gs_currentScore += 50;    if (usedEndSlots[0] && usedEndSlots[1] && usedEndSlots[2] && usedEndSlots[3] && usedEndSlots[4]){        usedEndSlots = [0,0,0,0,0];        gs_currentScore += 1000;        gs_levelNumber++;        gs_frogPosX = frogStartPosX;        gs_frogPosY = frogStartPosY;        gs_frogDirection = Direction_North;        draw_frog(gs_frogPosX, gs_frogPosY, gs_frogDirection, false);        activeSpriteObjects = [];                clearInterval(drawLogInterval);        clearInterval(drawVehicleInterval);        drawVehicleInterval = window.setInterval(vehicleGenerator, 1000 / gs_levelNumber);        drawLogInterval = window.setInterval(logGenerator, 500 / (gs_levelNumber * 1.5));                drawInitialVehicles();        drawInitialLogs();    }    gs_frogPosX = frogStartPosX;    gs_frogPosY = frogStartPosY;    gs_frogDirection = Direction_North;    draw_frog(gs_frogPosX, gs_frogPosY, gs_frogDirection, false);}function update_sprites(){    for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){            activeSpriteObjects[SI].update();            if (!spriteIsOnCanvas(activeSpriteObjects[SI])){                activeSpriteObjects.splice(SI, 1);                continue;            }            gameCanvasContext.drawImage(spriteSheet, activeSpriteObjects[SI].cropX, activeSpriteObjects[SI].cropY,                 activeSpriteObjects[SI].widthX, activeSpriteObjects[SI].widthY, activeSpriteObjects[SI].PosX, activeSpriteObjects[SI].PosY, activeSpriteObjects[SI].widthX, activeSpriteObjects[SI].widthY);    }}function frogger_isOutOfBounds(){    return (gs_frogPosX < 0 || gs_frogPosX > 380 || gs_frogPosY < 60 || gs_frogPosY > 500);}function frogger_isOnPlatform(){    var froggerSprite = new Sprite(((gs_frogDirection == Direction_North || gs_frogDirection == Direction_South) ? {CropX: 24, CropY: 18} : {CropX: 18, CropY: 20}), null, gs_frogPosX, gs_frogPosY, null);    for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){        if (spritesOverlap(activeSpriteObjects[SI], froggerSprite)){           if (activeSpriteObjects[SI].isPlatform){                return true;            }        }    }    return false;}function drowning_check(){    if (!win_check()){        if (gs_frogPosY > 0 && gs_frogPosY < 300 && !frogger_isOnPlatform()){           frogger_dies();         }    }}function collision_check(){    //Make a sprite object to represent frogger    var froggerSprite = new Sprite(((gs_frogDirection == Direction_North || gs_frogDirection == Direction_South) ? {CropX: 22, CropY: 16} : {CropX: 16, CropY: 22}), null, gs_frogPosX, gs_frogPosY, null);    for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){        if (spritesOverlap(activeSpriteObjects[SI], froggerSprite)){            if (activeSpriteObjects[SI].isDeadly){                frogger_dies();            } else if (activeSpriteObjects[SI].isPlatform){                if (activeSpriteObjects[SI].direction == Direction_East){                    gs_frogPosX += activeSpriteObjects[SI].speed                } else if (activeSpriteObjects[SI].direction == Direction_West){                    gs_frogPosX -= activeSpriteObjects[SI].speed                }                if (frogger_isOutOfBounds()){                    frogger_dies();                }            }        }    }}function game_over(){    clearInterval(drawVehicleInterval);    clearInterval(drawLogInterval);    draw_gameOver();    //Stop the user moving frogger    gs_frogPosX = -50;    gs_frogPosY = -50;    if (gs_currentScore > gs_highScore){        gs_highScore = gs_currentScore;    }        window.setTimeout(reset_game, 2000);    }function reset_game(){        clearInterval(drawVehicleInterval);    clearInterval(drawLogInterval);    clearInterval(redrawInterval);        usedEndSlots = [0,0,0,0,0];        gs_currentScore = 0;    gs_livesLeft = 5;    gs_levelNumber = 1;        gs_frogPosX = frogStartPosX;    gs_frogPosY = frogStartPosY;    gs_frogDirection = Direction_North;    draw_frog(gs_frogPosX, gs_frogPosY, gs_frogDirection, false);        redrawInterval = window.setInterval(updateGame, 25);    drawVehicleInterval = window.setInterval(vehicleGenerator, 1000 / gs_levelNumber);    drawLogInterval = window.setInterval(logGenerator, 250);        drawInitialVehicles();    drawInitialLogs();}function frogger_dies(){    draw_deadFrog(gs_frogPosX, gs_frogPosY);    gs_frogPosX = frogStartPosX;    gs_frogPosY = frogStartPosY;    gs_livesLeft--;        if (gs_livesLeft < 0){        activeSpriteObjects = [];        game_over();    } else {        gs_frogPosX = frogStartPosX;        gs_frogPosY = frogStartPosY;        gs_frogDirection = Direction_North;    }}function draw_deadFrog(frogPosX, frogPosY){    var mSprite = new Sprite({CropX: 30, CropY: 30, PosX: 300, PosY: 180}, Direction_North, frogPosX - 7, frogPosY - 5, 0);    mSprite.expireTime = "50";    mSprite.expires = true;        mSprite.update = function(){        if (this.direction == Direction_East){            this.PosX += this.speed;        } else if (this.direction == Direction_West){            this.PosX -= this.speed;        }        if (this.expires){             this.expireTime--;             if (this.expireTime < 0){                 for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){                    if (activeSpriteObjects[SI].expires && activeSpriteObjects[SI].expireTime < 0){                        activeSpriteObjects.splice(SI, 1);                        break;                    }                }             }         }    }        activeSpriteObjects.push(mSprite);}function generate_Fly(){    //Fly cannot be treated as a regular sprite, as it is not guaranteed to not    //be positioned such that it overlaps with other sprites    var startX, startY, startDirection;    if (Math.floor(Math.random() * 2)){        startX = 0;        startY = 100 + Math.floor(Math.random() * 400);        startDirection = Direction_East;        flyCoords = flyEast;    } else {        startX = 399;        startY = 100 + Math.floor(Math.random() * 400);        startDirection = Direction_West;        flyCoords = flyWest;    }    flySprite = new Sprite(flyCoords, startDirection, startX, startY, 0.5);        flySprite.update = function(){            if (this.direction == Direction_East){                this.PosX++;            } else {                this.PosX--;            }            if (this.PosX % 10 < 5){                this.PosY += (this.PosX % 10) / 2;            } else {                this.PosY -= ((this.PosX % 10) - 5) / 2;            }            gameCanvasContext.drawImage(spriteSheet, this.cropX, this.cropY,                 this.widthX, this.widthY, this.PosX, this.PosY, this.widthX, this.widthY);            if (!spriteIsOnCanvas(this)){                flySprite = null;            }        }}function draw_gameOver(){    var mSprite = new Sprite(gameOverText, Direction_North, 60, 150, 0);    mSprite.expireTime = "75";    mSprite.expires = true;        mSprite.update = function(){        if (this.direction == Direction_East){            this.PosX += this.speed;        } else if (this.direction == Direction_West){            this.PosX -= this.speed;        }        if (this.expires){             this.expireTime--;             if (this.expireTime < 0){                 for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){                    if (activeSpriteObjects[SI].expires && activeSpriteObjects[SI].expireTime < 0){                        activeSpriteObjects.splice(SI, 1);                        break;                    }                }             }         }    }        activeSpriteObjects.push(mSprite);}function drawInitialVehicles(){    //Draw level * 15 initial vehicles    for (v = 0; v < gs_levelNumber * 7; v++){        var car_startPosX, car_startPosY, car_direction, car_spriteVars;        if (Math.random() > 0.5){             var car_startPosY = 332 + Math.floor(Math.random() * 3) * 60;             car_startPosX = Math.floor(Math.random() * 200);             car_direction = Direction_East;             car_spriteVars = rightVehicleSprites[Math.floor(Math.random() * rightVehicleSprites.length)];        } else {             var car_startPosY = 362 + Math.floor(Math.random() * 2) * 60;             car_startPosX = Math.floor(Math.random() * 199) + 200;             car_direction = Direction_West;             car_spriteVars = leftVehicleSprites[Math.floor(Math.random() * leftVehicleSprites.length)];        }        var mSprite = new Sprite(car_spriteVars, car_direction, car_startPosX, car_startPosY, gs_levelNumber);        mSprite.isDeadly = true;                mSprite.update = function(){            if (this.direction == Direction_East){                this.PosX += this.speed;            } else if (this.direction == Direction_West){                this.PosX -= this.speed;            }        }                activeSpriteObjects.push(mSprite);    }}function drawInitialLogs(){    //Try to draw level * 20 initial logs    for (v = 0; v < gs_levelNumber * 20; v++){        var whichLane = Math.floor(Math.random() * 6);    var log_startPosY = 118 + whichLane * 31;    var log_startPosX, log_startPosY, log_direction, log_spriteVars;    if (whichLane == 0 || whichLane == 2 || whichLane == 3 || whichLane == 5){        //Draw a log        log_spriteVars = logSprites[Math.floor(Math.random()*logSprites.length)];        if (whichLane % 2 == 0){            //East            log_startPosX = Math.floor(Math.random() * 200);            log_direction = Direction_East;        } else {            //West            log_startPosX = Math.floor(Math.random() * 199) + 200;            log_direction = Direction_West;        }     } else {        //Draw turtles        log_spriteVars = logSprites[Math.floor(Math.random()*logSprites.length)];        if (whichLane % 2 == 0){            //East            log_startPosX = Math.floor(Math.random() * 200);            log_direction = Direction_East;        } else {            //West            log_startPosX = Math.floor(Math.random() * 199) + 200;            log_direction = Direction_West;        }     }    var mSprite = new Sprite(log_spriteVars, log_direction, log_startPosX, log_startPosY, gs_levelNumber);    for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){        if (spritesOverlap(mSprite, activeSpriteObjects[SI])){            return;        }    }    mSprite.isPlatform = true;    mSprite.update = function(){            if (this.direction == Direction_East){                this.PosX += this.speed;            } else if (this.direction == Direction_West){                this.PosX -= this.speed;            }        }    activeSpriteObjects.push(mSprite);    }}function vehicleGenerator(){    //get random lane in the vehicle area (332 to 453)    var car_startPosX, car_startPosY, car_direction, car_spriteVars;    if (Math.random() > 0.5){         var car_startPosY = 332 + Math.floor(Math.random() * 3) * 60;         car_spriteVars = rightVehicleSprites[Math.floor(Math.random() * rightVehicleSprites.length)];         car_startPosX = 0 - car_spriteVars.CropX;         car_direction = Direction_East;             } else {         var car_startPosY = 362 + Math.floor(Math.random() * 2) * 60;         car_startPosX = 399;         car_direction = Direction_West;         car_spriteVars = leftVehicleSprites[Math.floor(Math.random() * leftVehicleSprites.length)];    }    var mSprite = new Sprite(car_spriteVars, car_direction, car_startPosX, car_startPosY, gs_levelNumber);    mSprite.isDeadly = true;        mSprite.update = function(){        if (this.direction == Direction_East){               this.PosX += this.speed;            } else if (this.direction == Direction_West){               this.PosX -= this.speed;            }        }        activeSpriteObjects.push(mSprite);}function logGenerator(){    //get random lane in the log/turtle area (110 to 270)    //log, turtle, log log turtle log    var whichLane = Math.floor(Math.random() * 6);    var log_startPosY = 118 + whichLane * 31;    var log_startPosX, log_startPosY, log_direction, log_spriteVars;    if (whichLane == 0 || whichLane == 2 || whichLane == 3 || whichLane == 5){        //Draw a log        log_spriteVars = logSprites[Math.floor(Math.random()*logSprites.length)];        if (whichLane % 2 == 0){            //East            log_startPosX = 0 - log_spriteVars.CropX;            log_direction = Direction_East;        } else {            //West            log_startPosX = 399;            log_direction = Direction_West;        }     } else {        //Draw turtles        log_spriteVars = logSprites[Math.floor(Math.random()*logSprites.length)];        if (whichLane % 2 == 0){            //East            log_startPosX = 0 - log_spriteVars.CropX;            log_direction = Direction_East;        } else {            //West            log_startPosX = 399;            log_direction = Direction_West;        }     }    var mSprite = new Sprite(log_spriteVars, log_direction, log_startPosX, log_startPosY, gs_levelNumber);    for (var SI = 0 ; SI < activeSpriteObjects.length; SI++){        if (spritesOverlap(mSprite, activeSpriteObjects[SI])){            return;        }    }    mSprite.isPlatform = true;    mSprite.update = function(){            if (this.direction == Direction_East){                this.PosX += this.speed;            } else if (this.direction == Direction_West){                this.PosX -= this.speed;            }        }    activeSpriteObjects.push(mSprite);}function init_game(){        gameCanvas = document.getElementById('game');    gameCanvasContext = gameCanvas.getContext('2d');    spriteSheet = new Image();        /*     * Once the image has loaded, draw the base gamestate     */    gs_highScore = 0;        spriteSheet.onload = reset_game;    spriteSheet.src = "assets/frogger_sprites.png";    }/* * Handle key events */document.onkeydown = function(event){        var keyCode;       if(event == null){        keyCode = window.event.keyCode;    } else {        keyCode = event.keyCode;     }     switch(keyCode){        // Left         case 37:            gs_frogPosX -= 30;            if (frogger_isOutOfBounds()){                gs_frogPosX += 30;            }            gs_frogDirection = Direction_West;            break;         // Up         case 38:            gs_frogPosY -= 31;            if (frogger_isOutOfBounds()){                gs_frogPosY += 31;            } else {                gs_currentScore += 10;            }            gs_frogDirection = Direction_North;            break;         // Right         case 39:            gs_frogPosX += 30;            if (frogger_isOutOfBounds()){                gs_frogPosX -= 30;            }            gs_frogDirection = Direction_East;            break;         // Down        case 40:            gs_frogPosY += 31;            if (frogger_isOutOfBounds()){                gs_frogPosY -= 31;            }            gs_frogDirection = Direction_South;            break;         default:             break;     } }/* * Expects a direction of 0-4, where * 0 - North * 1 - East * 2 - South     * 3 - West *  * Expects a leaping value of true or false */function draw_frog(xpos, ypos, direction, leaping){    var cropFromX, cropFromY, cropWidthX, cropWidthY;        switch(direction){        case Direction_North:            cropFromX = 12;            cropFromY = 369            cropWidthX = 23;            cropWidthY = 17;          break;        case Direction_East:            cropFromX = 13;            cropFromY = 334            cropWidthX = 17;            cropWidthY = 23;            break;        case Direction_South:            cropFromX = 80;            cropFromY = 369;            cropWidthX = 23;            cropWidthY = 17;            break;        case Direction_West:            cropFromX = 82;            cropFromY = 335;            cropWidthX = 18;            cropWidthY = 23;            break;    }    gameCanvasContext.drawImage(spriteSheet, cropFromX, cropFromY, cropWidthX, cropWidthY, xpos, ypos, cropWidthX, cropWidthY);}function draw_score_info(score, highscore){    gameCanvasContext.fillStyle = "#00F000";    gameCanvasContext.font = "12pt Sans";    gameCanvasContext.fillText("Score: " + score, 5, 560);    gameCanvasContext.fillText("Highscore: " + highscore, 185, 560);}function draw_life_count(livesLeft){    for (var i=0; i < livesLeft; i++){         gameCanvasContext.drawImage(spriteSheet, 12, 333, 19, 25, (25 * i) + 5, 518, 19, 25);    }}function draw_level_count(levelNumber){    gameCanvasContext.fillStyle = "#00F000";    gameCanvasContext.font = "20pt Sans";    gameCanvasContext.fillText("Level " + levelNumber, 185, 540);}function draw_background(){    //Clear the canvas    gameCanvasContext.clearRect(0, 0, gameCanvas.width, gameCanvas.height);        //Draw the water base layer    gameCanvasContext.fillStyle="#191970";    gameCanvasContext.fillRect(0,0,399,310);         //Draw the road base layer    gameCanvasContext.fillStyle="#000";    gameCanvasContext.fillRect(0,310,399,310);        //Draw title & greenery    gameCanvasContext.drawImage(spriteSheet, 0, 0, 399, 110, 0, 0, 399, 110);        //Draw upper purple bar    gameCanvasContext.drawImage(spriteSheet, 0, 116, 399, 40, 0, 295, 399, 40);        //Draw lower purple bar    gameCanvasContext.drawImage(spriteSheet, 0, 116, 399, 40, 0, 480, 399, 40);}